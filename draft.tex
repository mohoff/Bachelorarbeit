\documentclass[11pt,a4paper,oneside]{report}
\usepackage[ngerman]{babel}
% \usepackage{url} or
\usepackage[utf8]{inputenc} % Displays German 'Umlaute' correctly. Also some workaround, see Bibliography Management#BibTeX in wikibooks
\usepackage{graphicx}
%\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{chngcntr}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{5}

% Enables consecutive figure and table numbering, independent of chapter count
\counterwithout{figure}{chapter}
\counterwithout{table}{chapter}

\addto{\captionsngerman}{\renewcommand*{\abstractname}{Abstract}}
%\renewcommand{\abstractname}{Abstract}

\newcommand{\bibtexFilename}{draft} % written without extension
\newcommand{\thema}{Sicherheitsbetrachtungen von Applikations-Containersystemen in Cloud-Infrastukturen am Beispiel Docker}
\newcommand{\fig}{Abb.}
\newcommand*{\signatureAndDate}{
    \par\noindent\makebox[2.5in]{\hrulefill} \hfill\makebox[2.0in]{\hrulefill}%
    \par\noindent\makebox[2.5in][l]{Unterschrift}      \hfill\makebox[2.0in][l]{Datum}%
}

\begin{document}
\pagenumbering{gobble} % No page numbers

\begin{titlepage}
	\centering
	% \includegraphics[width=0.15\textwidth]{example-image-1x1}\par\vspace{1cm}
	{\scshape\LARGE
		Hochschule der Medien
	\par}
	\vspace{1cm}
	{\scshape\Large
		Bachelorarbeit
	\par}
	\vspace{1.5cm}
	{\huge\bfseries
		\thema
	\par}
	\vspace{2cm}
	{\Large\itshape
		Moritz Hoffmann
	\par}
	\vspace{0.5cm}
	{\Large
		Studiengang: Mobile Medien\\
		Matrikelnummer: 26135\\
		E-Mail: \texttt{mh203@hdm-stuttgart.de}
	\par}
	\vspace{1.5cm}
	{\Large Dezember 2015\par}
	% Bottom of the page
	\vfill
	{\Large
		\emph{Erstbetreuer:}\hfill\emph{Zweitbetreuer:}\\
		Prof. Dr. Joachim Charzinski\hfill Patrick Fröger\\
		Hochschule der Medien\hfill ITI/GN, Daimler AG
	\par}

\end{titlepage}


\title{\thema}
\author{Moritz Hoffmann\\
  Studiengang Mobile Medien,\\
  Hochschule der Medien\\
  \texttt{mh203@hdm-stuttgart.de}}
\date{Dezember 2015}
% \date{\today}
\maketitle

%\pagenumbering{roman}

\chapter*{Eidesstattliche Erklärung}
\emph{„Hiermit versichere ich, Moritz Hoffmann, ehrenwörtlich, dass ich die vorliegende Bachelorarbeit mit dem Titel: „\thema“ selbstständig und ohne fremde Hilfe verfasst und keine anderen als die angegebenen Hilfsmittel benutzt habe. Die Stellen der Arbeit, die dem Wortlaut oder dem Sinn nach anderen Werken entnommen wurden, sind in jedem Fall unter Angabe der Quelle kenntlich gemacht. Die Arbeit ist noch nicht veröffentlicht oder in anderer Form als Prüfungsleistung vorgelegt worden. Ich habe die Bedeutung der ehrenwörtlichen Versicherung und die prüfungsrechtlichen Folgen (§26 Abs. 2 Bachelor-SPO (6 Semester), § 24 Abs. 2 Bachelor-SPO (7 Semester), § 23 Abs. 2 Master-SPO (3 Semester) bzw. § 19 Abs. 2 Master-SPO (4 Semester und berufsbegleitend) der HdM) einer unrichtigen oder unvollständigen ehrenwörtlichen Versicherung zur Kenntnis genommen.“
}
\vspace{1.5cm}
\signatureAndDate
\newpage


% Abstract
\begin{abstract}
\noindent\emph{English version:}\newline\newline
\noindent
....\\
..\\

\vspace{1cm}
\noindent\emph{Deutsche Version:}\newline\newline
\noindent
....\\
...\\
.\\
..\\

\end{abstract}

% Table of Contents
\tableofcontents

% Abbildungsverzeichnis
\listoffigures

% Tabellenverzeichnis
\listoftables

% \linespread{1.3}            % 1.5x line spacing
% \linespread{1.6}            % Double line spacing
% \hfill test                 % insert horizontal stretched space
% \vfill test                 % insert vertical stretched space
% ,,German quotation marks``  % deutsche Anfuehrungszeichen

% this is a comment
Hallo %\cite{myquote1}
One more line %\cite[S.2]{myquote1,myquote2}
jooooo \cite{presContainerDockerSec}

\begin{figure}[h] % with [p], images is displayed on own page
    \centering
    \includegraphics[width=1.0\textwidth]{./images/image.jpg}
    \caption{Awesome Image}
    \label{fig:awesome_image}
\end{figure}

lkasjdflkj asldkjf lasjkdflkadsjf ladksjflkjslkdjf    dslfjklaks df a sdfjaldsfj  ladksjf lkjlakjsd f asdf aljsdflkjasldfjalsdfj l adskjflj d f dslkfjalksdjf sd fljsdfkjsld f

\emph{dieser text ist kursiv}

asdfasdfasdfasdlkvalrkgjval  asdkfj  sldkfjlsdjfa adaher is kes ji lkaskdj ladskj a ldksfjll aldkfj lkj afsdlfkjl alsdkf jaldskfj la sdflaldsflas df sadfl sf

\texttt{das hier ist monotype}

% TODO: reformat chapter style with package titlesec
%\titleformat{\section}
%{\filcenter\normalfont\Large\bfseries}
%{\chaptertitlename~\thechapter} {0.5em} {}



% GLIEDERUNG
\chapter{Überblick}
\pagenumbering{arabic}
  % Container als leichtgewichtige Virtualisierung
  Virtualisierte Komponenten nutzen im Vergleich zu nativ (physisch) eingesetzten Komponenten eine zusätzliche Softwareschicht, die den virtualisierten Komponenten, üblicherweise als virtuelle Maschinen (VMs) bezeichnet, mehrere Abstraktionen anbietet, um Funktionen des Gastsystems zu nutzen \cite[S.2]{containerVirtPerformance}.

  Es existieren heutzutage mehrere Virtualisierungstechniken, wovon die Hypervisor-gestützen Methoden mit den Vertretern Xen, VMware und KVM die meistverbreitesten sind \cite[S.2]{containerVirtPerformance}. Die zwei prominentesten Virtualisierungstechniken, Hypervisor-basierte und Container-basierte Virtualisierung, werden in dieser Arbeit gegenübergestellt (INTERNE-REFERENZ hier?).

  Mit dem Release von Docker im Jahr 2013 erlebte die containerbasierte Virtualisierung einen Aufschwung, obwohl sie schon einige Jahre zuvor in der Form von XXXX und XXXX existierte (QUELLEN,mehrere da mehrere Bsp). Wie Docker den bis 2013 vorherrschenden Ruf von Containersystemen nachhaltig verändern konnte, nämlich dass Container noch nicht ausgereift seien \cite[S.8]{containerVirtPerformance}, ist im Kapitel \hyperref[dockerIntro]{\glqq{}Einführung in Docker\glqq{}} beschreiben.



  Virtualisierungstechnologien sind in den letzten Jahren sehr beliebt geworden. Einige Softwarelösungen wie Xen, VMware und KVM (QUELLEN) sowie Hardwaresupport von handelsüblichen Prozessoren (QUELLEN, siehe containerVirtPerformance) haben sich auf dem Markt etabliert.
  Die Vorteile von Virtualisierung sind Hardwareunabhängigkeit, Verfügbarkeit, Isolierung und Sicherheit, welche die Erfolgsgrundlage der Virtualisierung in Cloud-Infrastrukturen bilden.
  \cite[S.1]{containerVirtPerformance}

  Trotz ein paar intrinsischen Schwächen von Containerlösungen, werden Container bereits in einer Vielzahl von Szenarien eingesetzt \cite[S.6]{dockerBook}.

  Container sind in Infrastrukturen, in denen es auf Skalierbarkeit ankommt, trotz Sicherheitsbedenken beliebt. Vor allem "Multi-Tenant" Services werden gerne mit Docker eingesetzt.

  \section{Struktur dieser Arbeit}
    % Ist das die richtige Stelle für die Struktur? Oder besser als Punkt 1.1 direkt unter "Überblick"?

	\section{Arten von Virtualisierungen}
    % AUCH: Vergleich von Virtualisierungsarten
    \subsection{Hypervisor-basierte Virtualisierung}
      Bei Hypervisor-basierten Systemen laufen unabhängig voneinander eine oder mehrere Maschinen virtuell auf physischer Hardware (in der englischen Literatur auch "bare metal" genannt). Der Hypervisor, der auch \emph{Virtual Machine Monitor} (\emph{VMM}) genannt wird \cite[S.2]{containerVirtPerformance}, nimmt dabei die Rolle eines Vermittlers zwischen Host-OS und Gast-OS ein \cite[S.6]{dockerBook} und abstrahiert dem Gast, also einer VM, die Funktionen des Hosts.

      Durch diese Technik läuft in jeder VM ein eigenes Betriebssystem, das von solchen anderer VMs komplett isoliert läuft. Durch die Abstraktion des zwischenliegenden Hypervisors ist es möglich, mehrere unterschiedliche Betriebssysteme auf einem physikalischen Host auszuführen \cite[S.2]{containerVirtPerformance}.

      Der größte Kritikpunkt dieser Art von Virtualisierung ist deren hoher Bedarf an Hostressourcen, da diese für jede gestartete VM komplett virtualisiert werden müssen, sodass innerhalb der VM ein Gast-OS ausgeführt werden kann \cite[S.1]{dockerIntroIEEE}\cite[S.3]{dockerLXCKub}.

      Bekannte Vertreter von Hypervisorn sind die kommerziellen \emph{ESXI} von VMware und \emph{Hyper-V} von Mircosoft, sowie die Open-Source Hypervisor \emph{Xen} und \emph{KVM} (QUELLEN, u.a. \cite[S.1]{dockerLXCKub}).

    \subsection{Container-basierte Virtualisierung}
      (Benötigt keine Emulations- oder Hypervisorschicht \cite[S.7]{dockerBook}.)

      Container-basierte Virtualisierung ist eine leichtgewichtige Alternative zu Hypervisor-basierten Virtualisierungen \cite[S.2]{containerVirtPerformance}.

      Container sind durch den Unix-Befehl \emph{chroot} inspriert, der schon seit 1979 im Linux-Kernel integriert ist. In \emph{FreeBSD} wurde eine erweiterte Variante von \emph{chroot} verwendet, um \emph{Jails} (FreeBSD-spezifischer Begriff) umzusetzen. In Solaris wurde dieser Mechanismus in Form von \emph{Zones} (Solaris-spezifischer Begriff) weiter verbessert und es etablierte sich der Name \emph{Container}, als weitere proprietäre Lösungen von HP und IBM zur selben Zeit auf dem Markt erschienen \cite[S.2]{dockerLXCKub}.

      Einen Hypervisor wird in diesem Ansatz nicht eingesetzt. Vielmehr wird das native System und dessen Ressourcen partitioniert, sodass mehrere isolierte User-Space Instanzen betrieben werden können, die Container genannt werden \cite[S.2]{containerVirtPerformance} .

      Während ein Hypervisor für jede VM das komplette Gast-OS abstrahiert, werden für Container direkt Funktionen des Hosts zur Verfügung gestellt. Deswegen werden Containerlösungen auch als Virtualisierungen auf Betriebssystemebene (des Hosts) bezeichnet \cite[S.6]{dockerBook}\cite[S.2]{containerVirtPerformance}. Aus technischer Sicht ist der Hypervisor ein Stück Software, das eine Abstraktion der Hardware bereitstellt, während Container direkt via \emph{System Calls} mit der Hostmaschine kommunizieren. Das hat zur Folge, dass alle Container direkt mit einem Host kommunizieren und sich damit den Kernel dessen teilen \cite[S.2]{containerVirtPerformance}\cite[S.3]{dockerLXCKub}.

      Sowohl Hypervisor-gestützte VMs als auch Container erwecken aus Sicht des Gasts den Eindruck, dass ein alleinstehendes Betriebssystem ausgeführt wird (QUELLE: “OpenVZ,” 2012. [Online]. Available: http://www.openvz.org). Um diese Illusion zu schaffen, wird jedoch wie beschrieben jeweils ein anderer Ansatz eingesetzt.

      Das Containern zugrunde liegende Feature der Isolation wird in der Regel mit \emph{namespaces}, einem Feature des Kernels, realisiert. Die Verteilung und das Management der Hostressourcen wird mit \emph{control groups} umgesetzt (QUELLE?). Beide Techniken werden den Kapiteln \hyperref[secNamespaces]{\glqq{}Namespaces\grqq{}} und \hyperref[secCgroups]{\glqq{}Control Groups\grqq{}} genauer betrachtet.

      % Grafik für Container-based und Hypervisor-based Virtualization und deren Schichten (einmal mit, einmal ohne Hypervisor)

      Containerlösungen umfassen die Technologien \emph{OpenVZ}, \emph{Solaris Zones}, sowie Linux-Container wie \emph{Linux VServer}, \emph{LXC} \cite[S.7]{dockerBook}\cite[S.1]{containerVirtPerformance} und \emph{Docker}, welches im Fokus dieser Arbeit steht.

      Moderne Container können als vollwertige Systeme betrachtet werden, nicht mehr als ursprünglich vorgesehen, reine Ausführungsumgebungen \cite[S.7]{dockerBook}.

      In Container-basierten Systemen hingegen, laufen die Container im "User Space" direkt auf dem Kernel des Host-OS und nutzen dessen \emph{System Call}-Interface \cite[S.6+7]{dockerBook}. Dadurch kommt es im Vergleich zu Hypervisor-Virtualisierungen zu einer fast nativen Performance \cite[S.1]{containerVirtPerformance}, da der Virtualisierungs-Overhead des Hypervisors wegfällt. Unter dem Gesichtspunkt der Rechenleistung beispielsweise, kommt es bei Containerlösungen im Durchschnitt zu einem Overhead von ca. 4\%, wenn diese mit der nativen Leistung einer festen Hardwarekonfiguration verglichen wird \cite[S.4]{containerVirtPerformance}\cite[S.5]{IBMcontVMcomparison}. In traditionellen Virtualisierungen beansprucht der Hypervisor allein etwa 10-20\% der Hostkapazität \cite[S.2]{dockerIntroIEEE}\cite[S.5]{IBMcontVMcomparison}. In der Praxis machen sich diese beiden Verhältnisse an einer hohe Dichte an Containern auf einem Container-basiertem Host und dadurch einer indirekt besseren Resourcenausnutzung bemerkbar \cite[S.7+8]{dockerBook}.

      Ein Benchmarktest, der den Durchsatz (Operationen pro Sekunde) eines \emph{VoltDB}-Setups von Hypervisor-basierte Cloudlösungen mit Container-basierten Cloudlösungen verglich, kam zu dem Ergebnis, dass die Containerlösung unter genanntem Gesichtspunkt eine fünffache Leistung aufwies \cite[S.2+3]{voltdb}.

      Auch im Lifecycle von virtuellen Instanzen bieten Container Vorteile: Während in traditionellen VMs das komplette Gast-OS neu gestartet werden muss, um Änderungen zu übernehmen, entspricht ein Containerneustart nur einem Neustart eines Prozesses auf Host \cite[S.2]{dockerLXCKub}.

      Container-Lösungen erlauben es, mehrere voneinander isolierte "User Space"-Instanzen parallel auf einem einzigen physischen Host zu betreiben \cite[S.6]{dockerBook}. Dadurch, dass ein Hypervisor in einer solchen Konfiguration nicht existiert und die Container direkt Hostkernel-Features nutzen, gibt es einen entscheidenden Nachteil für Containerlösungen - und damit auch Docker - gegenüber Hypervisor-basierter Virtualisierung: Das Container-Betriebssystem muss wie das Host-Betriebsystem Linux-basiert sein. In einem Host auf dem Ubuntu Server installiert ist, können nur weitere Linux-Distributionen als Container laufen. Ein Microsoft Windows kann also nicht als Container auf genannten Host gestartet werden, da die Kernel miteinander nicht kompatibel sind \cite[S.6]{dockerBook}. Diese Inflexibilität im Spektrum der einsetzbaren Betriebssysteme liegt den Containerlösungen zugrunde.

      Außerdem werden Container als weniger sicher im Vergleich zur Hypervisor-gestützen Virtualisierung gesehen \cite[S.6]{dockerBook}.

      Hingegen muss in containerbasierten Systemen nicht das gesamte Betriebssystem virtualisiert werden, da von den Containern direkt auf den Host-Kernel zugegriffen wird. Zum Einen schrumpft dadurch die Angriffsfläche des Hosts \cite[S.6]{dockerBook}, da, wie später noch zu sehen ist, die Zugriffsrechte der Container auf den Host sehr feingranular festgelegt werden müssen. Zum Anderen entsteht durch diese Tatsache ein Risko im Design, weil Host-Features ohne Hypervisor direkt genutzt werden.

	  \subsection{Einordnung Docker}
      Docker gehört zu den Technologien der Container-basierten Virtualisierung.
      % Unbedingt Quelle containerVirtPerformance anschauen, da werden mehrere Containerloesungen miteinander verglichen.

      Docker nutzt moderne Linux-Kernelfeatures, wie z.b. \emph{control groups} und \emph{namespaces}, um ein Resourcenmanagement zwischen Containern und eine effektive Isolierung der Container vom Hostsystem zu realisieren \cite[S.7]{dockerBook}.

      Docker ist wie in KAPITEL-ZUVOR angedeutet, nicht die erste containerbasierte Virtualisierungslösung. Einige ältere Containersysteme, wie z.B. \emph{Solaris Zones}, gibt es schon viel länger als Docker, aber wurden allerdings nie von der Industrie als Lösung akzeptiert. Worauf beruht also der Erfolg von Docker in den letzten Jahren? Dieser Frage werde ich im folgenden Kapitel nachgehen.
  \section{Einführung in Docker}
  \label{dockerIntro}
    Docker ist eine unter der Apache 2.0 Lizenz veröffentlichte Open-Source Engine, die den Einsatz von Anwendungen in Containern automatisiert. Es ist überwiegend in der Programmiersprache \emph{Golang} von dem Unternehmen \emph{Docker, Inc.} (vormals \emph{dotCloud Inc.}), implementiert \cite{githubDocker}\cite[S.7]{dockerBook}.

    Docker erweitert \emph{LXC} um eine Schnittstelle auf Kernel- und Applikationslevel \cite[S.2]{dockerLXCKub}.

    % Erfolg von Docker von businessinsiders.com trends.
    % --> siehe Quelle slideshareDockercon15
    % Auch checken: Statistika, google trends


    Der große Vorteil von Docker gegenüber älteren Containerlösungen ist das Level an Abstraktion und die Bedienungsfreundlichkeit, die Nutzern ermöglicht wird. Während sich Lösungen vor Docker auf dem Markt durch deren schwierige Installation und Management sowie schwachen Automatisierungsfunktionen nicht etablieren konnten, addressiert Docker genau diese Schwachpunkte \cite[S.7]{dockerBook} und bietet neben Containern viele Tools und einen Workflow für Entwickler, die beide die Arbeit mit Containern erleichtern soll \cite[S.1]{dockerIntroIEEE}.



    % Einfaches "Getting Started": es braucht nur einen minimalen Host mit einem kompatiblen Linux-Kernel und die Docker-Binary, die ausgeführt werden soll \cite[S.8]{dockerBook}.

    Wenn wie von Docker empfohlen in jedem Container nur eine Anwendung läuft, begünstigt das eine moderne Service-orientierte Architektur mit \emph{Microservices}. Nach dieser Architektur werden Anwendungen oder Services verteilt zur Verfügung gestellt und durch eine Serie an miteinander kommunizierenden Containern umgesetzt. Der Grad an Modularisierung der dadurch ensteht, kann für die Verteilung, die Skalierung und das Debugging von Service- oder Anwedungskomponeten (Container) eingesetzt werden \cite[S.9]{dockerBook}. Je nach Usecase können Container Testumgebungen, Anwendungen bzw. Teile davon, oder Replikate komplexer Anwendungen für Entwicklungs- und Produktionszwecke abbilden. Container also nehmen die Rolle austauschbarer, kombinierbarer und portierbarer Module eines Systems ein \cite[S.12]{dockerBook}.

    Ein bekanntes Problem bei der Softwareentwicklung ist, dass Code in der Umgebung eines Entwicklers fehlerfrei ausgeführt wird, jedoch in Produktionsumgebungen Fehler verursacht. In der Regel fallen beide Umgebungen in unterschiedliche personelle Zuständigkeitsbereiche, was vereinfacht eine Übergabe von Entwicklungs- nach Produktionsumgebung mit sich zieht. Diesem Umstand wurde mit der Einführung von \emph{DevOps}-Teams entgegengewirkt. Diese Teams sind sowohl für die Entwicklung (\emph{Dev} = Development) eines Produkts als auch den Betrieb (\emph{Ops} = Operations) dessen verantwortlich. Der Overhead einer Übergabe fällt dadurch weg. (DAZU QUELLEN FINDBAR?)

    Einen anderen Ansatz dieses Problem zu lösen, liefern Container: Das Kernproblem im genanntem Szenario sind die Entwicklungs- und Produktionsumgebung, zwischen denen Code ausgetauscht wird, da diese nicht identisch sind. Mithilfe von Containern können in der ansonsten gleichen Konstellation nun ganze Container, die den Code beinhalten, zwischen den Umgebungen ausgetauscht werden. Der große Vorteil der Container ist, dass die Ausführungsumgebung in diesem bereits enthalten ist, also mit sehr hoher Wahrscheinlichkeit in einer Entwicklerinfrastruktur als auch auf einem Produktionsinfrastruktur startfähig ist (Anstelle von "-infrastruktur" kann auch von "Umgebung" gesprochen werden)(BEGRIFFLICHKEIT ERKLAEREN: es sind alles "Umgebungen" (Entwicklerumgebung, Produktionsumgebung, Containerumgebung) --> KLARER FORMULIEREN).
    % Unterschiedliche "Cuts" im Schichtenmodell von Visulisierung. Alt: Zwischen Guest und App. NEU: Zwischen Guest und Host.



    Eine weitere wichtige Eigenschaft von Docker ist Konsistenz: Die Umgebungen, in denen Softwareentwickler Code schreiben, sind identisch mit den Umgebungen, die später auf Servern laufen.


    Die Wahrscheinlichkeit, dass ein Fehler erst im Betrieb auftritt, nicht aber in der Entwicklung, wird dadurch sehr klein gehalten \cite[S.8]{dockerBook}.



    Quellcode kann inklusive virtualisierter Ausführungsumgebung flexibel von einem Laptop auf einen Testserver und später auf einen physischen oder virtualisierten Produktionsserver oder Cloud-Infrastruktur, wie z.B. Microsoft Azure, geschoben werden. Dieser kurzlebige Zyklus zwischen Entwicklung, Testen und Deployment erlaubt einen effizienten Workflow \cite[S.8+12]{dockerBook}.
    Da Quellcode das wertvollste Asset der meisten IT-Firmen ist und dieser erst dann Wert hat, wenn er bei einem Kunden ausgeführt wird, macht den beschriebenen Workflow zu einem wichtigen Entscheidungsgrund bei der Wahl der Entwicklerumgebung \cite[S.1]{dockerIntroIEEE}.

    % Zwei große Usecases: Continous Integration (Jenkins...) und Continuous Deployment \cite[S.2]{dockerIntroIEEE}.

    % Docker kann auf jedem x64 Host installiert und gestartet werden \cite[S.15]{dockerBook}.

    % WOHIN HIERMIT ?
    % Auch Startups wie CoreOS, MesoSphere und SaltStack, die an den Erfolg von Docker anschließen wollen, haben sich gebildet und unterstützen Kubernetes.
    % ^    /cite[S.4]{dockerLXCKub}

    Die Eigenheiten von Docker sowie die gängige Begrifflichkeiten im Docker-Ökosystem, werden in den folgenden Unterkapiteln genauer beleuchtet.
    \subsection{Container}
      % Metapher mit dem Docker-Wal, der Container lädt: Docker als Frachtschiff, mit dem Container verschifft werden.

      Der Begriff \glqq{}Container\grqq{} ist bisher schon oft gefallen, deswegen will ich auf ihn zuerst eingehen.

      Docker-Container beinhalten eine idealerweise minimale Laufzeitumgebung, in der eine oder mehrere Anwendungen laufen.

      In Bezug zu anderen Docker-Begriffen, enthält ein Container ein Software-Image und erlaubt eine Reihen von Operationen, die auf ihn angewandt werden können. Darunter fallen z.B. das Erstellen, Starten, Stopen, Neustarten und Beenden eines Containers. Welchen Inhalt einen Container hat, also ob ein Container auf einem Datenbank- oder Webserver-Image beruht, ist dafür unerheblich \cite[S.12]{dockerBook}\cite[S.2]{dockerLXCKub}.



      Container werden als priveligiert bezeichnet, wenn sie mit Root-Rechten gestartet werden. Standardmäßig startet ein Container mit einem reduzierten Set an sog. \texttt{capabilities}, welches keine vollen Root-Rechte umfasst (BELEG).

      % Der Hosts selbst muss auch gemanaged werden.
      % Docker als Anwendung muss installiert, gemanaged, und deployed werden auf einem Host.
      % Docker-Container müssen orchestriert, gemanged und deployed werden. Oft im Zusammenspiel mit externen Service und Tools.
      % In Hypervisor-basierten Virtualisierungen kommen meist Puppet, Chef )und Vagrant) zum Einsatz, die obigen Management-Anforderungen erfüllen können.
      % Aber beim Einsatz von Docker sind diese Tools nicht unbedingt notwendig,  Docker repräsentiert oft kurzlebige Container, read-only Container, die einfach zu ersetzen sind ohne die Notwendigkeit Containerzustände zu speichern oder wiederherzustellen. Wenn ein Zustand von Bedeutung ist, kann es einfacher sein diesen neu zu erstellen anstatt einen bestehnden Zustand zu korrigieren.
      % ^  \cite[S.14]{dockerBook}

      % In der Praxis werden herkömmliche, oft historisch gewachsene Lösungen nicht vollständig und sofort auf Docker umgerüstet. Mit der Koexistenz von Hypervisor-basierten Virtualisierungen und Containerlösungen, werden auch Configuration Management Tools wie Puppet und Chef im Zusammenhang mit Docker verwendet.
      % ^  \cite[S.14]{dockerBook}


      % Container können innerhalb von Sekundenbruchteilen starten
      % ^  \cite[S.1]{dockerIntroIEEE}

    \subsection{Images}
    \label{dockerImages}
      Ein Image besteht aus ein oder mehreren Schichten (Layers), wobei eine Schicht auch ein Image darstellen kann.

      Images liegen Containern als statische Files zugrunde. Container werden auf der Basis von Images gestartet. Images sind durch ein \emph{Union}-Dateisystem in Schichten gegliedert, die überlagert ein Image ergeben, das als Container gestartet werden kann \cite[S.11]{dockerBook}.

      \emph{Union}-Dateisysteme haben gemeinsam, dass sie alle auf dem \emph{Copy-on-write}-Modell basieren \cite[S.8]{dockerBook}. Konkrete Vertreter sind \emph{AuFS}, \emph{Btrfs} und \emph{Device Mapper} \cite[S.3]{dockerIntroIEEE}.

      Die Schichten eines Images umfassen in der Regel jeweils eine minimale Ausführungsumgebung mit Bibliotheken, Binaries und Hilfspaketen sowie den Quellcode der Anwendung, die im Container ausgeführt werden soll. Die Schichtenstruktur erlaubt es, Images modularisiert aufzubauen, sodass sich Änderungen eines Images zur auf eine Schicht auswirkt. Soll z.B. in ein bestehendes Image der Webserver \emph{Nginx} integriert werden, kann dieser mit dem Kommando \texttt{sudo apt-get install nginx} installiert werden, was eine neue Schicht im Image erzeugt. Mit mehreren ähnlichen Images ist gewährleistet, dass nur die konkreten Unterschiede zwischen diesen als eigene Schichten hinterlegt sind. Eine gemeinsame Codebasis, die von mehreren Images genutzt wird, liegt in wenigen Schichten, die sich die Images teilen \cite[S.3]{dockerIntroIEEE}.
      % Vergleich mit git commit und VCS (S.3 dockerIntroIEEE)


      % Copy-on-write erklären.

      % Screenshot von Imagelayer.io, um Aufbau von einem Image zu sehen

      % Screenshot von docker ps / docker history um Liste von Images zu sehen.
      % Images bekommen einen eindeutigen Hashwert zugewiesen, lassen sich



      Images werden Schritt für Schritt erstellt, z.B. mit den folgenden Aktionen \cite[S.11]{dockerBook}:

      \begin{itemize}
        \item Eine Datei hinzufügen
        \item Ein Kommando ausführen, z.B. ein Tool mittels des Paketmanagers \texttt{apt} installieren
        \item Einen Port öffnen, z.B. den Port 80 für einen Webserver
      \end{itemize}

      Images sind einfach portierbar und können geteilt, gespeichert und aktualisiert werden \cite[S.11]{dockerBook}.

      Auf der Basis von existierenden Images können durch das Hinzufügen neuer Schichten durch oben beschriebene Aktionen, neue Images erstellt werden (EIGENES STATEMENT).

      Über die Kommandozeile kann z.B. das Image eines \emph{Nginx}-Webservers von der öffentlichen Docker-Registry mit dem Befehl \texttt{docker pull nginx} auf die lokale Maschine gespeichert werden.

      %Was eine Registry ist wird im folgenden Kapitel erklärt.

    \subsection{Registries}
      Eine Registry ist ein gehosteter Service, der Images in Repositories anbietet.

      Docker stellt eine Vielzahl an Images öffentlich in einer eigenen Registry, dem Docker Hub \cite[S.11]{dockerBook}, zur Verfügung. Für dieses System kann jeder Nutzer einen Account anlegen und eigenständig Images hochladen. Das Docker-Hub bietet bereits mehr als 150.000 Repositories, die etwa 240.000 Nutzer zusammenstellten und hochluden, zur freien Verwendung an (Stand Juni 2015) \cite[S.16]{slideshareDockercon15}. Die Einträge im Hub können von Nutzern bewertet werden. Außerdem wird angezeigt, wie oft ein Image bereits über das Hub bezogen wurde.

      Ein Repository besteht aus mindestens einem Image. Um Images in einem Repository voneinander zu unterscheiden, werden Images Tags zugewiesen, um beispielweise mehrere Versionen eines Images in einem Repository zu kennzeichnen. Die Images werden nach dem Schema \texttt{<repository>:<tag>} identifiziert. So gibt es z.B. im offiziellen Repository des Webservers \emph{Nginx} Images mit den Tags \texttt{latest}, \texttt{1}, \texttt{1.9} und \texttt{1.9.9} \cite{dockerhubNginx}. Wenn bei dem Download kein Tag angegeben ist, wie in Kapitel wird automatisch das aktuellste Image \texttt{latest} bezogen, wie es im \hyperref[dockerImages]{letzten Kapitel \glqq{}Images\grqq{}} praktiziert wurde.

      % es gibt eine Trusted Registry. Die noch erklären.

      % Bsp. geben für z.B. Ubuntu mit vielen Unterversionen und dem Identifier "latest".

      % Weitere beispiele aus dockerBook: Nginx web server, MySQL Datenbank

      % Es gibt offizielle Images, die von trusted parties verwaltet werden

      Docker bietet außerdem an, private Registries zu erstellen. Diese können dann, z.B. gesichert von einer unternehmenseigenen Firewall, betrieben werden.
    \subsection{Dockerfile}
      Ein Dockerfile ist eine Datei mit selbigem Namen, die ein oder mehrere Anweisungen enthält. Letztere werden konsekutiv ausgeführt und führen jeweils zu einer neuen Schicht, die später in das generierte Image einfließt. Damit stellen Dockerfiles eine Möglichkeit dar, Images automatisiert und einfach zu generieren.
      % "einfach" schreiben? Klingt populistisch

      Eine Anweisung kann z.B. sein, ein Tool zu installieren oder zu starten, eine Umgebungsvariable festlegen oder einen Port öffnen.

      % Bsp. Dockerfile (mit drin: envvar, export port, baseimage, maintainer, authoer, apt-get)


    \subsection{Client und Server}
      Docker selbst ist nach einem Client-Server-Modell aufgebaut: Ein Docker-Client kommuniziert mit einem Docker-Daemon, also ein Prozess der den Server abbildet. Beide Teile können auf einer Maschine oder einzeln auf unterschiedlichen Hosts laufen. Wie in \fig \ref{fig:intro_dockerArchitecture} zu sehen ist, sind auch mehrere Docker-Clients möglich.
      % in beiden Fällen wird eine RESTful API genutzt? Setzt das docker binary nur CLI-Kommandos in REST-API-Aufrufe um?
      % Docker-Binary \texttt{docker}

      \begin{figure}[h]
          \centering
          \includegraphics[width=0.7\textwidth]{./images/intro_dockerArchitecture.jpg}
          \caption{Die Client-Server-Architektur von Docker \cite[S.10]{dockerBook}.}
          \label{fig:intro_dockerArchitecture}
      \end{figure}

      % Kommunikation zwischen Client und Server via TCPIP oder Unix Sockets?

    \subsection{Containerformat \texttt{libcontainer}}
      \texttt{libcontainer} ist ein natives Linux Containerformat, das sowohl Docker als auch die Containerplatform \emph{Linux Containers} (\emph{LXC}) verwendet.

      % Seit XXX ist \texttt{libcontainer} das Standardformat für Docker.

\chapter{Ziel der Arbeit/Forschungsfrage}
  % Kommt man von Container auf Host-OS? Von Container auf anderen Container? ~etc.
  % 5-6 Sicherheitsziele erwähnen. Mit Forschungsfrage in Bezug bringen --> später bei Isolierung und Ressourcenverwaltung wieder aufgreifen
\chapter{Security aus Linux Kernel-Features}
  % namespaces/etc (was es ist) in Einleitung mit rein? 1.) Erklaeren, 2.) Security/Docker untersuchen dazu im Security Hauptteil
  % 2 Unterkapitel, inhatliche Überschneidung evtl., Grund nennen warum so gegliedert, ...
  % \cite[S.3]{dockerIntroIEEE} --> umgangsprachlich erkleart wie mit namespaces und cgroups gearbeitet wird
	\section{Isolierung}
    % Isolierung erklären, erfüllt X Schutzziele, Bezug auf Forschungsfrage
		\subsection{\texttt{namespaces}}
    \label{secNamespaces}
			\subsubsection{\texttt{user namespaces}}
      % Future implementation, da sehr neu. Trotzdem Konzept erklären und wie Docker-Security davon profitiert.
		\subsection{\texttt{capabilities}}
			\subsubsection{Beispiele, \texttt{/proc}-Verzeichnis, (Un-)Mounten des Host-Filesystems}
      % Gehört das unter 'capabilities'? Oder eigener Punkt bzw. woanders dazu?
		\subsection{Mandatory Access Control (MAC)}
      % Herausfinden, ob das wirklich Unterkapitel von "Isolierung" wird. Evtl. getrennt davon listen.
			\subsubsection{Beispiel SELinux}
      % Macht Sinn das erst am Ende zu machen, wenn noch Zeit ist. Weil SELinux im Detail mehr Exkurs wird.
      \subsubsection{AppArmor}
      % Optional, da auf MAC alzu sehr eingehen nicht zu sehr im Scope sein sollte.
	\section{Ressourcenverwaltung}
    % Sicherheitsziel: Availability, Bezug auf Forschungsfrage
    % Ressourcenverteilung und -management
    % Storage, CPU, HDD, RAM, IO, Network
		\subsection{\texttt{cgroups}}
    \label{secCgroups}

    % network namespace:
    % Standardmäßig werden für Container keine Ports geöffnet. Manche Applikationen machen jedoch nur Sinn, wenn sie Ports nutzen können, daher können diese manuell in dem Dockerfile (INTERNE REFERENZ) freigegeben werden.
    % Container werden virtuelle Netzwerkinterfaces zur Verfügung gestellt. Dadurch können z.B. mehrere Container betrieben werden, die Webserver beinhalten, die alle auf Port 80 eingestellt sind. Außerhalb der Container können diese Containerports mithilfe von NAT (sicher NAT?) auf unterschiedliche Ports des Hosts abgebildet werden.
    % ^ \cite[S.3]{dockerIntroIEEE}


	\section{Docker im Vergleich zu anderen Containerlösungen}
  % Optional?
\chapter{Security im Docker-Ökosystem}
  % ### Hier mit Patrick weitermachen ###
  % Je nach Vorankommen, können hier ganze Sektions weggelassen werden imo.
  % Tendenziell mehr die Themen zuerst, die direkt mit Security zu tun haben.
  % Auch Fokus auf die neusten Entwicklungen (2015 und 2016) in Sachen Sicherheit und neue Docker-Features
  \section{Docker Images und Registries}
    % Siehe /cite{slideshareDockercon15}, slide 51
		\subsection{neues Signierungs-Feature}
	\section{Docker Daemon}
		\subsection{REST-API}
		\subsection{Support von Zertifikaten}
  \section{Containerprozesse}
    % offenbar gibts Probleme mit PID=0, da dieser Besonderheiten aufweist (siehe Hackernews Link)
	\section{Docker Cache}
	\section{\texttt{privileged} Container}
	\section{Networking}
		\subsection{\texttt{bridge} Netzwerk}
		\subsection{\texttt{overlay} Netzwerk}
		\subsection{DNS}
		\subsection{Portmapping}
	\section{Daten-Container}
	\section{Docker mit VMs}
  \section{Sicherheitskontrollen für Docker}
    % Gibt auf Github Skripte, die einige Docker-Parameter/Einstellungen prüfen (Links iwo in den Bookmarks)
	\section{Tools rund um Docker}
    \subsection{Docker-Erweiterungen}
      \subsubsection{Docker Swarm}
      \subsubsection{Docker Compose}
      \subsubsection{Nautilus Project}
    \subsection{Third-Party Tools}
  		\subsection{Vagrant}
  		\subsection{Kubernetes}
        % neueres Cluster-Management Tool von Google
        % Hat Relevanz fuer Herr Fahner/Daimler

        Ein Hauptfeature von Containern ist deren flexibler Einsatz in Anwendungsclustern, die eine Multi-Tier-Anwendung / Multi-Tenant-Architektur abbilden.
        Im Juni 2014 hat Google das Open-Source Tool \emph{Kubernetes} angekündigt, das Cluster mit Docker-Containern verwalten soll. Laut Google ist Kubernetes die Entkopplung von Anwendungscontainern von Details des Hosts.
        Soll in Datencentern die Arbeit mit Containern vereinfachen.
        % Brint angeblich tolles Networking-Feature mit.

        Neben einigen Startups, haben sich Google, Microsoft, VMware, IBM und Red Hat als \emph{Kubernetes}-Unterstützer geäußert.
\chapter{Docker in Unternehmen/Clound-Infrastrukturen}
  % Wichtiges Kapitel für Daimler, mein Chef, Management
  % Kapitel, das erst angegangen wird, wenn min. Kapitel 1 steht (Januar 2016 oder später).

  % ???: Transscript aus Besprechung mit Herr Fahner und Patrick:
  % Welche Security-Features uebernimmt die Cloud, welche muss Docker gewaehrleisten. Was
  % bieten MS Azure/Amazon's AWS/etc fuer Mechanismen an?
  % Welche Möglichkeiten zur sicheren Docker-Integration bieten diese?
  % Wortlaut Patrick: Wie funktionierts bei Azure, wie funktionierts wenn man es
  % selbst implementiert.

  % --> mir ist nich klar, was ich da untersuchen kann.

  % Hypervisor-basierte Clouds:
  % Amazon Web Services (AWS) nutzt XEN.
  % Terremark, Savvis, Bluelock nutzen ESXi.
  % AT&T, HP, Comcast, Orange nutzen KVM.
  % Microsoft Azure und MS Private Cloud nutzen hauseigenen Hyper-V.
  % Container-basierte CLouds:
  % Google, IBM/Softlayer, Joyent (RECHERCHIEN: welche Containerplatform sie nutzen. Google glaube ich lmctfy)
  % ^  \cite[S.2]{dockerLXCKub}

  % formale Definitionen von "Cloud Computing" ...
  % "bare metal cloud": Zuweisung von rein physikalischen Servern und Setups. Kein Overhead von Hypervisorn oder Containerization.
  % ^  \cite[S.1]{dockerLXCKub}

  % Containeranwedungen (Service Discovery Tools) wie HAProxy, Zookeeper, etcd und Consul können eingehende Verbindungen auf mehrere Webserver-Container verteilen --> flexibel und skalierbar. Komplizierte Anwendungen sind deswegen realisierbar.
  % ^   \cite[S.4]{dockerIntroIEEE}

  % Tools wie Docker Swarm und Kubernetes erlauben es, Docker-basierte Appliaktionsstacks auch auf mehreren physikalischen Hosts zu realisieren.
  % Prototyp \emph{libswarm}, jetzt Docker Swarm.
  % Auch für Skalierung, Autoskalierung und Redundanz sehr gut
  % ^   \cite[S.4]{dockerIntroIEEE}

  % Moegliche Kombinationen von VMs, OS, Container, Anwedungen sind in \cite[S.3]{dockerLXCKub}

  % Evtl. mit in Ausblick mit rein:
  % However, using containers for security isolation might not be a good idea. In an August 2013 blog, 4 one of Docker’s engineers expressed optimism that containers would eventually catch up to VMs from a security standpoint. But in a presentation given in January 2014, 5 the same engineer said that the only way to have real isolation with Docker is to either run one Docker per host, or one Docker per VM. If high security is needed, it might be worth sacrificing the performance of a pure-container deployment by introducing a VM to obtain more tried and true isolation. As with any other technology, you need to know the deployment’s security requirements, and make appropriate decisions.
  % ^   \cite[S.3]{dockerLXCKub}



\chapter{Fazit/Ausblick}
  % Wenig Angriffsvektoren auf Docker/Container bekannt. "Sichergehen" kann man nur mit Konzepten wie "Docker in VMs" und "VMs in Docker".
  % neuste Docker-Releases und deren Fokus (Enterprise,Production-Readiness,Security)
  % seit Juli 2015 ist standardisiertes Containerformat der big player in Arbeit
  % Ausblick im Kontext von Container VS. konventioneller Virtualisierung


  Spekulation in der Industrie ist, dass sich Organisationen und Unternehmen zusammenschließen und sich auf eine neue, universale Lösung einigen, die die heutigen Fähigkeiten der sich ergänzenden Technologien Docker und Kubernetes, abdeckt \cite[S.4]{dockerLXCKub}.


%\subsection{Subsektion blabla}
%\subsubsection{Subsubsektion blablabla}
%\paragraph{Paragraph soundso}
%\subparagraph{SubParagraph soundso}

% Anhang
\appendix
  % Falls benoetigt
  % Evtl. beispielhafte Dockerfiles anzeigen

% Bibliography
\bibliographystyle{plain}
\bibliography{\bibtexFilename} % specify name of bibfile

\end{document}
